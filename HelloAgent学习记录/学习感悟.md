<div align="center">
<img src="https://raw.githubusercontent.com/datawhalechina/Hello-Agents/main/docs/images/4-figures/4-4.png" alt="" width="70%"/>
<br>
<em>图1: 不同 Agent Loop 的选择策略</em>

</div>

## 习题

> <strong>提示</strong>:部分习题没有标准答案，重点在于培养学习者对智能体范式设计的综合理解和实践能力。

1. 本章介绍了三种经典的智能体范式:`ReAct`、`Plan-and-Solve` 和 `Reflection`。请分析:
   
   - 这三种范式在"思考"与"行动"的组织方式上有什么本质区别？
   - 如果要设计一个"智能家居控制助手"（需要控制灯光、空调、窗帘等多个设备，并根据用户习惯自动调节），你会选择哪种范式作为基础架构？为什么？
   - 是否可以将这三种范式进行组合使用？若可以，请尝试设计一个混合范式的智能体架构，并说明其适用场景。
2. 在4.2节的 `ReAct` 实现中，我们使用了正则表达式来解析大语言模型的输出（如 `Thought` 和 `Action`）。请思考:
   
   - 当前的解析方法存在哪些潜在的脆弱性？在什么情况下可能会失败？
   - 除了正则表达式，还有哪些更鲁棒的输出解析方案？
   - 尝试修改本章的代码，使用一种更可靠的输出格式，并对比两种方案的优缺点
3. 工具调用是现代智能体的核心能力之一。基于4.2.2节的 `ToolExecutor` 设计，请完成以下扩展实践:
   
   > <strong>提示</strong>:这是一道动手实践题，建议实际编写代码
   
   - 为 `ReAct` 智能体添加一个"计算器"工具，使其能够处理复杂的数学计算问题（如"计算 `(123 + 456) × 789/ 12 = ?` 的结果"）
   - 设计并实现一个"工具选择失败"的处理机制:当智能体多次调用错误的工具或提供错误的参数时，系统应该如何引导它纠正？
   - 思考:如果可调用工具的数量增加到$50$个甚至$100$个，当前的工具描述方式是否还能有效工作？在可调用工具数量随业务需求显著增加时，从工程角度如何优化工具的组织和检索机制？
4. `Plan-and-Solve` 范式将任务分解为"规划"和"执行"两个阶段。请深入分析:
   
   - 在4.3节的实现中，规划阶段生成的计划是"静态"的（一次性生成，不可修改）。如果在执行过程中发现某个步骤无法完成或结果不符合预期，应该如何设计一个"动态重规划"机制？
   - 对比 `Plan-and-Solve` 与 `ReAct`:在处理"预订一次从北京到上海的商务旅行（包括机票、酒店、租车）"这样的任务时，哪种范式更合适？为什么？
   - 尝试设计一个"分层规划"系统:先生成高层次的抽象计划，然后针对每个高层步骤再生成详细的子计划。这种设计有什么优势？
5. `Reflection` 机制通过"执行-反思-优化"循环来提升输出质量。请思考:
   
   - 在4.4节的代码生成案例中，不同阶段使用的是同一个模型。如果使用两个不同的模型（例如，用一个更强大的模型来做反思，用一个更快的模型来做执行），会带来什么影响？
   - `Reflection` 机制的终止条件是"反馈中包含<strong>无需改进</strong>"或"达到最大迭代次数"。这种设计是否合理？能否设计一个更智能的终止条件？
   - 假设你要搭建一个"学术论文写作助手"，它能够生成初稿并不断优化论文内容。请设计一个多维度的Reflection机制，从段落逻辑性、方法创新性、语言表达、引用规范等多个角度进行反思和改进。
6. 提示词工程是影响智能体最终效果的关键技术。本章展示了多个精心设计的提示词模板。请分析:
   
   - 对比4.2.3节的 `ReAct` 提示词和4.3.2节的 `Plan-and-Solve` 提示词，它们显然存在结构设计上的明显不同，这些差异是如何服务于各自范式的核心逻辑的？
   - 在4.4.3节的 `Reflection` 提示词中，我们使用了"你是一位极其严格的代码评审专家"这样的角色设定。尝试修改这个角色设定（如改为"你是一位注重代码可读性的开源项目维护者"），观察输出结果的变化，并总结角色设定对智能体行为的影响。
   - 在提示词中加入 `few-shot` 示例往往能显著提升模型对特定格式的遵循能力。请为本章的某个智能体尝试添加 `few-shot` 示例，并对比其效果。
7. 某电商初创公司现在希望使用"客服智能体"来代替真人客服实现降本增效，它需要具备以下功能:
   
   a. 理解用户的退款申请理由
   
   b. 查询用户的订单信息和物流状态
   
   c. 根据公司政策智能地判断是否应该批准退款
   
   d. 生成一封得体的回复邮件并发送至用户邮箱
   
   e. 如果判断决策存在一定争议（自我置信度低于阈值），能够进行自我反思并给出更审慎的建议
   
   此时作为该产品的负责人:
   
   - 你会选择本章的哪种范式（或哪些范式的组合）作为系统的核心架构？
   - 这个系统需要哪些工具？请列出至少3个工具及其功能描述。
   - 如何设计提示词来确保智能体的决策既符合公司利益，又能保持对用户的友好态度？
   - 这个产品上线后可能面临哪些风险和挑战？如何通过技术手段来降低这些风险？

# 智能体范式习题解答

## 习题1：范式分析与应用

### 1.1 思考/行动组织方式的本质区别

```python
# ReAct范式：交替进行
for step in task:
    thought = reason(current_state)      # 思考
    action = decide_action(thought)      # 行动
    observation = execute(action)        # 观察
    # 循环继续...
```

```python
# Plan-and-Solve范式：先规划后执行
plan = create_comprehensive_plan(task)   # 一次性完整规划
for step in plan:
    result = execute_step(step)          # 按顺序执行
    # 无需中间思考
```

```python
# Reflection范式：执行后反思
solution = generate_initial_solution(task)
while not satisfactory:
    feedback = evaluate(solution)        # 反思
    solution = improve(solution, feedback) # 优化
    # 迭代直到满意
```

**核心差异总结**：

- **ReAct**：`循环[思考→行动→观察]`，**交互式、增量式**推理
- **Plan-and-Solve**：`先规划→后执行`，**批处理、预见式**推理
- **Reflection**：`生成→反思→优化`，**迭代式、质量导向**推理

### 1.2 智能家居助手架构选择

```python
# 推荐架构：以ReAct为基础，辅以轻量规划
class SmartHomeAgent:
    def __init__(self):
        self.daily_routine = None  # 来自Plan-and-Solve的高层计划
        self.learned_habits = {}   # 来自Reflection的学习结果
  
    def react_cycle(self, sensor_data):
        """ReAct核心循环"""
        thought = "用户可能在休息，调暗灯光并降低空调噪音"
        action = "调节灯光亮度至30%，设置空调静音模式"
        observation = execute_home_action(action)
        # 持续响应环境变化
```

**选择理由**：

1. **实时响应需求**：智能家居环境动态多变（温度变化、人员移动）
2. **信息不完整**：无法预先知道所有用户即时需求
3. **工具调用**：需要调用多个设备API（灯光、空调、窗帘等）

### 1.3 混合范式架构设计

```python
# 混合范式智能家居架构
class HybridHomeAgent:
    def __init__(self):
        self.planner = PlanAndSolveModule()      # 高层规划
        self.executor = ReActModule()           # 实时执行
        self.reflector = ReflectionModule()     # 长期优化
  
    def run(self):
        # 1. 高层规划（每天早上执行一次）
        daily_plan = self.planner.generate_daily_plan(
            user_schedule, weather_forecast
        )
      
        # 2. 实时执行（持续运行）
        while True:
            sensor_data = read_sensors()
          
            # ReAct循环处理实时事件
            if unexpected_event(sensor_data):
                thought, action = self.executor.react_cycle(sensor_data)
                execute_action(action)
          
            # 按计划执行常规任务
            elif time_for_scheduled_task():
                execute_scheduled_task(daily_plan)
          
            # 3. 周期性反思（每小时一次）
            if time_for_reflection():
                self.reflector.analyze_and_optimize(
                    energy_usage, user_feedback
                )
```

**适用场景**：

- **智慧办公楼**：固定工作时间表（规划）+ 实时占用调整（ReAct）+ 能效优化（反思）
- **养老监护**：日常护理计划（规划）+ 紧急情况响应（ReAct）+ 健康模式学习（反思）
- **酒店客房**：客人入住流程（规划）+ 个性化服务调整（ReAct）+ 满意度优化（反思）

## 习题2：输出解析的鲁棒性

### 2.1 正则表达式的脆弱性

```python
# 当前脆弱的正则解析
import re

def parse_react_output(text):
    # 这种解析容易失败
    thought_match = re.search(r'Thought:\s*(.*?)\nAction:', text, re.DOTALL)
    action_match = re.search(r'Action:\s*(.*?)\nAction Input:', text)
  
    # 失败情况1：模型使用同义词
    # 模型输出 "想法：..." 而不是 "Thought：..."
  
    # 失败情况2：格式不严格
    # 模型输出 "Thought: xyz Action: abc" （没有换行）
  
    # 失败情况3：额外内容干扰
    # 模型在中间添加无关解释
```

**失败场景**：

1. **格式变异**：大小写不一致、中英文混用、换行符缺失
2. **内容干扰**：模型添加额外解释或注释
3. **嵌套结构**：思考中包含JSON或代码块

### 2.2 更鲁棒的解析方案

```python
# 方案1：使用Pydantic结构化输出
from pydantic import BaseModel
from typing import Optional

class AgentResponse(BaseModel):
    thought: str
    action: Optional[str] = None
    action_input: Optional[dict] = None
    final_answer: Optional[str] = None

def parse_with_pydantic(model_output: str) -> AgentResponse:
    # 提示词要求模型输出JSON
    prompt = f"""
    请严格按照以下JSON格式输出：
    {{
        "thought": "你的推理过程",
        "action": "工具名称或null",
        "action_input": {{"参数": "值"}}或null,
        "final_answer": "最终答案或null"
    }}
  
    任务：{task}
    你的输出：
    """
    # 模型返回JSON，直接解析
    import json
    data = json.loads(model_output)
    return AgentResponse(**data)
```

```python
# 方案2：使用LangChain的OutputParser
from langchain.output_parsers import PydanticOutputParser
from langchain.prompts import PromptTemplate

parser = PydanticOutputParser(pydantic_object=AgentResponse)

prompt = PromptTemplate(
    template="回答以下问题：{question}\n{format_instructions}",
    input_variables=["question"],
    partial_variables={
        "format_instructions": parser.get_format_instructions()
    }
)

# 方案3：LLM函数调用（OpenAI格式）
tools = [
    {
        "type": "function",
        "function": {
            "name": "search_web",
            "description": "搜索网络信息",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {"type": "string"}
                }
            }
        }
    }
]
# 模型直接返回结构化函数调用请求
```

### 2.3 代码修改与对比

```python
# 修改前的正则解析版本
class RegexParser:
    def parse(self, text):
        thought_pattern = r'Thought:\s*(.*?)(?:\nAction:|\nFinal Answer:|$)'
        action_pattern = r'Action:\s*(\w+)'
        action_input_pattern = r'Action Input:\s*(.*?)(?:\nThought:|\nFinal Answer:|$)'
      
        # 多个正则匹配，容易出错
        thought = re.search(thought_pattern, text, re.DOTALL)
        action = re.search(action_pattern, text)
      
        return {
            "thought": thought.group(1) if thought else "",
            "action": action.group(1) if action else None
        }

# 修改后的结构化解析版本
class StructuredParser:
    def __init__(self):
        self.schema = {
            "type": "object",
            "properties": {
                "thought": {"type": "string"},
                "action": {"type": "string", "enum": ["search", "calculate", "query"]},
                "action_input": {"type": "object"},
                "final_answer": {"type": "string"}
            },
            "required": ["thought"]
        }
  
    def parse(self, text):
        # 要求模型输出JSON
        prompt = f"输出JSON格式：{json.dumps(self.schema, ensure_ascii=False)}\n\n{text}"
      
        try:
            # 尝试解析JSON
            result = json.loads(self.extract_json(text))
            return self.validate_schema(result)
        except json.JSONDecodeError:
            # 失败时回退到正则
            return self.fallback_parse(text)
  
    def extract_json(self, text):
        """从可能包含其他文本的内容中提取JSON"""
        # 查找第一个 { 和最后一个 }
        start = text.find('{')
        end = text.rfind('}') + 1
        if start >= 0 and end > start:
            return text[start:end]
        return text
```

**方案对比**：

| 方案           | 优点                     | 缺点                        | 适用场景               |
| -------------- | ------------------------ | --------------------------- | ---------------------- |
| **正则表达式** | 简单、快速、无额外依赖   | 脆弱、难维护、扩展性差      | 原型验证、格式严格可控 |
| **结构化输出** | 鲁棒、类型安全、易扩展   | 需要模型配合、可能增加token | 生产环境、复杂输出     |
| **函数调用**   | 原生支持、最可靠、标准化 | 平台依赖、灵活性受限        | 商用API、工具调用场景  |

## 习题3：工具调用与工程优化

### 3.1 计算器工具实现

```python
import math
import re
from typing import Dict, Any

class ToolExecutor:
    def __init__(self):
        self.tools = {}
        self.register_tool("calculator", "执行数学计算", self.calculate)
  
    def calculate(self, expression: str) -> float:
        """安全计算数学表达式"""
        # 清理表达式
        cleaned = re.sub(r'[^0-9+\-*/().^%√πe]', '', expression)
      
        # 替换常用数学符号
        cleaned = cleaned.replace('^', '**').replace('√', 'math.sqrt')
      
        # 添加数学常量
        if 'π' in cleaned:
            cleaned = cleaned.replace('π', 'math.pi')
        if 'e' in cleaned:
            cleaned = cleaned.replace('e', 'math.e')
      
        # 安全验证
        if self.is_safe_expression(cleaned):
            try:
                # 使用eval但限制命名空间
                safe_dict = {"math": math, "__builtins__": None}
                result = eval(cleaned, {"__builtins__": None}, safe_dict)
                return float(result)
            except Exception as e:
                return f"计算错误: {str(e)}"
        else:
            return "表达式包含不安全字符"
  
    def is_safe_expression(self, expr: str) -> bool:
        """验证表达式安全性"""
        # 只允许数字、运算符、括号和math函数
        pattern = r'^[0-9+\-*/().\s^%]+$|math\.[a-z]+'
        return bool(re.match(pattern, expr))
  
    # 使用示例
    def demo(self):
        result = self.calculate("(123 + 456) × 789 / 12")
        print(f"计算结果: {result}")
        # 支持更多功能
        print(self.calculate("2^10 + √16"))  # 幂运算和开方
        print(self.calculate("sin(π/2)"))    # 三角函数
```

### 3.2 工具选择失败处理机制

```python
class RobustToolExecutor(ToolExecutor):
    def __init__(self, max_attempts: int = 3):
        super().__init__()
        self.max_attempts = max_attempts
        self.error_history = {}  # 记录每个会话的错误
      
    def execute_with_retry(self, session_id: str, tool_name: str, params: dict):
        """带重试和引导的工具执行"""
        attempts = 0
      
        while attempts < self.max_attempts:
            try:
                # 尝试执行
                result = self.execute_tool(tool_name, params)
              
                # 成功则重置错误计数
                self.error_history[session_id] = 0
                return result
              
            except (ToolNotFoundError, InvalidParamError) as e:
                attempts += 1
                self.error_history[session_id] = attempts
              
                if attempts >= self.max_attempts:
                    return self.emergency_guidance(session_id, e)
                else:
                    # 提供纠正建议
                    suggestion = self.generate_suggestion(e, attempts)
                    return {
                        "error": str(e),
                        "suggestion": suggestion,
                        "remaining_attempts": self.max_attempts - attempts
                    }
  
    def emergency_guidance(self, session_id: str, error: Exception) -> dict:
        """多次失败后的紧急引导"""
        error_count = self.error_history.get(session_id, 0)
      
        guidance = {
            "紧急干预": "系统检测到多次工具调用失败",
            "可能原因": self.analyze_error_pattern(error),
            "建议操作": [
                "1. 请用更简单的语言重新描述需求",
                "2. 或尝试以下可用工具:",
                self.get_simplified_tool_list(),
                "3. 是否需要人工协助？"
            ]
        }
      
        # 限制后续工具调用范围
        self.restrict_tool_access(session_id)
      
        return guidance
  
    def generate_suggestion(self, error: Exception, attempt: int) -> str:
        """根据错误类型生成建议"""
        suggestions = {
            1: "请检查工具名称是否正确，可用工具有：",
            2: "请确认参数格式，是否需要示例？",
            3: "尝试分解任务，先完成更简单的步骤"
        }
      
        base_suggestion = suggestions.get(attempt, "请重新尝试")
      
        if isinstance(error, ToolNotFoundError):
            similar = self.find_similar_tools(error.tool_name)
            return f"{base_suggestion} {list(self.tools.keys())[:5]}... 类似工具：{similar}"
        else:
            return f"{base_suggestion} 错误详情：{str(error)}"
  
    def restrict_tool_access(self, session_id: str):
        """限制问题会话的工具访问"""
        # 只允许基础工具
        basic_tools = ["calculator", "search", "query"]
        self.session_restrictions[session_id] = basic_tools
```

### 3.3 大规模工具管理优化

```python
# 方案1：分层分类管理
class HierarchicalToolManager:
    def __init__(self):
        self.categories = {
            "data_query": {
                "description": "数据查询工具",
                "tools": ["query_database", "search_logs", "get_metrics"]
            },
            "data_processing": {
                "description": "数据处理工具",
                "tools": ["filter_data", "aggregate", "transform"]
            },
            "external_apis": {
                "description": "外部API调用",
                "tools": ["send_email", "call_webhook", "notify_slack"]
            }
        }
  
    def select_tool(self, task_description: str) -> list:
        """根据任务描述选择工具类别"""
        # 简单的关键词匹配
        for category, info in self.categories.items():
            if any(keyword in task_description for keyword in info["keywords"]):
                return info["tools"]
        return []

# 方案2：向量化语义检索
import numpy as np
from sentence_transformers import SentenceTransformer

class VectorToolRetriever:
    def __init__(self):
        self.model = SentenceTransformer('all-MiniLM-L6-v2')
        self.tool_embeddings = {}
        self.tool_descriptions = {}
      
    def add_tool(self, name: str, description: str):
        """添加工具并生成向量"""
        self.tool_descriptions[name] = description
        self.tool_embeddings[name] = self.model.encode(description)
  
    def retrieve_tools(self, query: str, top_k: int = 5) -> list:
        """语义检索最相关的工具"""
        query_embedding = self.model.encode(query)
      
        similarities = {}
        for name, embedding in self.tool_embeddings.items():
            similarity = self.cosine_similarity(query_embedding, embedding)
            similarities[name] = similarity
      
        # 返回最相关的工具
        sorted_tools = sorted(similarities.items(), key=lambda x: x[1], reverse=True)
        return [tool[0] for tool in sorted_tools[:top_k]]
  
    def cosine_similarity(self, a, b):
        return np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))

# 方案3：元工具（工具推荐器）
class MetaToolRecommender:
    def __init__(self, tool_executor: ToolExecutor):
        self.executor = tool_executor
      
    def recommend_tools(self, task_context: dict) -> dict:
        """分析任务并推荐工具链"""
        task_type = self.classify_task(task_context["description"])
      
        recommendations = {
            "simple_query": ["search_database", "format_results"],
            "data_analysis": ["fetch_data", "clean_data", "analyze", "visualize"],
            "workflow": ["trigger_workflow", "monitor_progress", "send_report"]
        }
      
        return {
            "task_type": task_type,
            "recommended_workflow": recommendations.get(task_type, []),
            "estimated_steps": len(recommendations.get(task_type, [])),
            "alternative_tools": self.suggest_alternatives(task_type)
        }
  
    def execute_with_recommendation(self, task: str) -> Any:
        """使用推荐的工具链执行任务"""
        recommendation = self.recommend_tools({"description": task})
      
        results = []
        for tool_name in recommendation["recommended_workflow"]:
            # 动态生成参数（这里简化处理）
            params = self.generate_params(tool_name, task)
            result = self.executor.execute_tool(tool_name, params)
            results.append(result)
          
            # 检查是否继续
            if self.should_stop(result, tool_name):
                break
      
        return self.aggregate_results(results)
```

**工程优化总结**：

| 工具规模     | 推荐方案          | 关键技术             | 优势               |
| ------------ | ----------------- | -------------------- | ------------------ |
| **<20个**    | 简单注册+名称匹配 | 字典查找、字符串匹配 | 简单高效           |
| **20-100个** | 分类分层管理      | 工具分类、关键词匹配 | 可维护性好         |
| **>100个**   | 向量化语义检索    | 嵌入向量、相似度计算 | 智能推荐、扩展性强 |
| **动态增长** | 元工具+工作流     | 工作流引擎、自动编排 | 自动化程度高       |

## 习题4：Plan-and-Solve范式深入

### 4.1 动态重规划机制

```python
class DynamicReplanningAgent:
    def __init__(self):
        self.original_plan = []
        self.execution_history = []
      
    def execute_with_replanning(self, task):
        """带动态重规划的执行"""
        # 1. 初始规划
        plan = self.planning_phase(task)
      
        step_index = 0
        while step_index < len(plan):
            current_step = plan[step_index]
          
            # 2. 执行当前步骤
            result = self.execution_phase(current_step)
            self.execution_history.append((current_step, result))
          
            # 3. 检查执行结果
            if self.needs_replanning(result, current_step):
                # 4. 触发重规划
                remaining_task = self.reconstruct_remaining_task(
                    plan[step_index:], result
                )
              
                new_plan = self.replanning_phase(
                    remaining_task, 
                    self.execution_history
                )
              
                # 5. 替换后续计划
                plan = plan[:step_index] + new_plan
                print(f"步骤{step_index}后重规划，新计划：{new_plan}")
          
            step_index += 1
      
        return self.execution_history
  
    def needs_replanning(self, result, step):
        """判断是否需要重规划"""
        checkpoints = [
            result.get("status") == "failed",          # 步骤失败
            result.get("confidence", 0) < 0.5,         # 置信度低
            self.unexpected_output(result, step),      # 意外输出
            self.external_change_detected(),           # 环境变化
            self.timeout_exceeded(step)                # 超时
        ]
        return any(checkpoints)
  
    def replanning_phase(self, remaining_task, history):
        """基于历史的重规划"""
        prompt = f"""
        原始任务剩余部分：{remaining_task}
        执行历史：{history}
      
        由于步骤'{history[-1][0]}'执行{history[-1][1]['status']}，
        请重新规划剩余步骤，考虑：
        1. 跳过失败步骤的替代方案
        2. 调整步骤顺序
        3. 分解复杂步骤
      
        输出新的步骤列表：
        """
      
        # 调用LLM生成新计划
        new_plan = self.llm_generate_plan(prompt)
        return self.validate_plan(new_plan)
  
    def reconstruct_remaining_task(self, remaining_steps, last_result):
        """基于最后结果重建剩余任务描述"""
        # 如果步骤失败，可能需要修改任务描述
        if last_result.get("status") == "failed":
            return f"原任务受阻于'{remaining_steps[0]}'，需要绕行方案"
        return f"继续完成：{' -> '.join(remaining_steps)}"
```

### 4.2 预订旅行任务范式对比

```python
# Plan-and-Solve方案（更适合）
class TravelPlanner:
    def plan_trip(self, from_city, to_city, requirements):
        """一次性生成完整旅行计划"""
        plan = [
            "1. 查询北京到上海的航班，筛选商务舱",
            "2. 根据航班时间选择浦东机场附近的五星级酒店",
            "3. 预订酒店接送或租车服务",
            "4. 协调航班、酒店、租车的时间衔接",
            "5. 生成完整行程单和预订确认"
        ]
      
        # 批量执行所有步骤
        results = []
        for step in plan:
            result = self.execute_step(step)
            if result["status"] == "failed":
                # 需要协调重试
                self.adjust_dependent_steps(plan, step_index)
            results.append(result)
      
        return self.compile_itinerary(results)

# ReAct方案对比
class ReactiveTravelAgent:
    def book_trip(self, from_city, to_city):
        """交替决策可能低效"""
        steps = []
      
        # 可能出现的低效循环
        thought1 = "先查航班"
        action1 = search_flights("北京", "上海", "business")
        # 发现没有合适航班
        # 重新思考...
        thought2 = "也许可以中转"
        action2 = search_flights("北京", "南京", "business")
        # 又需要重新考虑酒店...
```

**范式选择分析**：

- **Plan-and-Solve优势**：
  
  - 预订任务**步骤间强依赖**（酒店依赖航班时间）
  - 需要**全局协调优化**（避免时间冲突）
  - 可以**批量获取信息**（比多次API调用高效）
- **ReAct适用场景**：
  
  - 用户需求**模糊或变化**（"我想去个暖和的地方"）
  - 需要**实时探索选项**（比较多个目的地）
  - 环境**高度不确定**（航班突然取消）

### 4.3 分层规划系统设计

```python
class HierarchicalPlanner:
    def __init__(self):
        self.abstract_levels = 3  # 抽象层级数
      
    def hierarchical_plan(self, task):
        """分层规划主流程"""
        # 第一层：抽象战略规划
        strategic_plan = self.strategic_planning(task)
      
        detailed_plan = []
        for abstract_step in strategic_plan:
            # 第二层：战术分解
            tactical_steps = self.tactical_decomposition(abstract_step)
          
            for tactical_step in tactical_steps:
                # 第三层：操作级详细步骤
                operational_steps = self.operational_planning(tactical_step)
                detailed_plan.extend(operational_steps)
      
        return {
            "strategic": strategic_plan,
            "tactical": self.group_by_tactical(detailed_plan),
            "operational": detailed_plan
        }
  
    def strategic_planning(self, task):
        """高层抽象规划（做什么）"""
        prompt = f"""
        将任务分解为3-5个高层目标：
        任务：{task}
      
        高层目标（抽象，不涉及具体操作）：
        1. 
        2. 
        3. 
        """
        return ["解决交通", "安排住宿", "准备地面交通", "协调时间"]
  
    def tactical_decomposition(self, abstract_step):
        """中层战术分解（怎么做）"""
        decompositions = {
            "解决交通": [
                "选择交通方式（飞机/高铁）",
                "查询班次和时间",
                "比较价格和服务"
            ],
            "安排住宿": [
                "确定酒店标准和位置",
                "查询空房和价格",
                "查看评价和设施"
            ]
        }
        return decompositions.get(abstract_step, [abstract_step])
  
    def operational_planning(self, tactical_step):
        """操作级详细步骤（具体执行）"""
        steps = {
            "查询班次和时间": [
                "访问航空公司官网API",
                "设置查询参数：日期、舱位",
                "解析返回的航班列表",
                "筛选符合时间的选项"
            ],
            "比较价格和服务": [
                "收集各渠道价格",
                "比较退改签政策",
                "评估累积里程",
                "选择最优选项"
            ]
        }
        return steps.get(tactical_step, [tactical_step])
```

**分层规划优势**：

1. **复杂度管理**：将复杂任务分解为可管理的层级
2. **重用性**：高层计划可复用于类似任务
3. **灵活性**：可在不同层级进行调整
4. **可解释性**：清晰的规划结构便于调试
5. **并行处理**：不同层级可独立优化

## 习题5：Reflection机制优化

### 5.1 多模型策略的影响

```python
class MultiModelReflection:
    def __init__(self, fast_model, strong_model):
        self.fast_model = fast_model  # 用于执行
        self.strong_model = strong_model  # 用于反思
      
    def reflect_and_improve(self, initial_output, task):
        """使用强模型反思，快模型执行"""
        # 第一轮：快速生成初稿
        draft = self.fast_model.generate(task)
      
        iterations = 0
        current_best = draft
      
        while iterations < self.max_iterations:
            # 使用强模型进行深度反思
            critique = self.strong_model.reflect(current_best, task)
          
            if self.is_sufficient(critique):
                break
              
            # 生成改进指导
            guidance = self.extract_guidance(critique)
          
            # 使用快模型执行改进
            improved = self.fast_model.improve(
                current_best, 
                guidance
            )
          
            # 质量评估
            if self.is_improvement(improved, current_best):
                current_best = improved
              
            iterations += 1
      
        return current_best
  
    def cost_benefit_analysis(self):
        """成本效益分析"""
        # 假设模型调用成本
        fast_model_cost = 0.01  # 美元/次
        strong_model_cost = 0.10  # 美元/次
      
        scenarios = [
            {
                "strategy": "仅强模型",
                "iterations": 3,
                "total_cost": 3 * strong_model_cost,
                "expected_quality": 0.95
            },
            {
                "strategy": "混合模型",
                "fast_calls": 5,
                "strong_calls": 2,
                "total_cost": (5 * fast_model_cost + 2 * strong_model_cost),
                "expected_quality": 0.90
            }
        ]
      
        return scenarios
```

**影响分析**：

- **优势**：
  
  - **成本优化**：强模型用于关键反思，快模型处理常规执行
  - **质量提升**：强模型的深度反思能力带来更好改进
  - **并行可能**：可以同时使用多个专业模型反思不同方面
- **挑战**：
  
  - **一致性**：不同模型可能有不同"风格"
  - **协调开销**：需要在模型间传递和转换信息
  - **错误传播**：反思模型的错误会误导执行模型

### 5.2 智能终止条件设计

```python
class IntelligentTermination:
    def __init__(self):
        self.metrics_history = []
      
    def should_terminate(self, current_output, previous_output, 
                        iteration, feedback):
        """智能终止条件判断"""
        conditions = []
      
        # 1. 质量收敛检测
        if self.has_converged():
            conditions.append(("质量收敛", True))
      
        # 2. 改进幅度阈值
        improvement = self.calculate_improvement(
            current_output, previous_output
        )
        if improvement < self.min_improvement_threshold:
            conditions.append(("改进不足", True))
      
        # 3. 检测振荡/循环
        if self.detected_oscillation():
            conditions.append(("检测到振荡", True))
      
        # 4. 外部验证通过
        if self.external_validation_passed(current_output):
            conditions.append(("外部验证通过", True))
      
        # 5. 时间/成本限制
        if iteration >= self.max_iterations:
            conditions.append(("达到最大迭代", True))
        if self.exceeded_time_budget():
            conditions.append(("超时", True))
      
        # 加权决策
        termination_score = self.calculate_termination_score(conditions)
        return termination_score > self.termination_threshold
  
    def calculate_improvement(self, current, previous):
        """计算改进幅度"""
        # 使用多个维度评分
        metrics = {
            "correctness": self.evaluate_correctness(current, previous),
            "completeness": self.evaluate_completeness(current, previous),
            "clarity": self.evaluate_clarity(current, previous),
            "conciseness": self.evaluate_conciseness(current, previous)
        }
      
        # 加权平均
        weights = {"correctness": 0.4, "completeness": 0.3, 
                  "clarity": 0.2, "conciseness": 0.1}
        total_improvement = sum(
            metrics[m] * weights[m] for m in metrics
        )
      
        self.metrics_history.append(total_improvement)
        return total_improvement
  
    def has_converged(self):
        """检测是否收敛"""
        if len(self.metrics_history) < 3:
            return False
      
        # 最近3次改进幅度都很小
        recent = self.metrics_history[-3:]
        avg_improvement = sum(recent) / len(recent)
        return avg_improvement < self.convergence_threshold
  
    def detected_oscillation(self):
        """检测振荡模式"""
        if len(self.metrics_history) < 4:
            return False
      
        # 检查是否在几个状态间来回切换
        pattern = self.metrics_history[-4:]
        differences = [pattern[i+1] - pattern[i] for i in range(3)]
      
        # 符号交替变化表明振荡
        signs = [1 if d > 0 else -1 for d in differences]
        oscillation_score = abs(sum(signs))  # 全同号=3，交替=1
      
        return oscillation_score <= 1
```

### 5.3 学术论文写作助手的多维度Reflection

```python
class AcademicPaperReflector:
    def __init__(self):
        self.critics = {
            "logic": LogicCritic(),
            "innovation": InnovationCritic(),
            "language": LanguageCritic(),
            "citation": CitationCritic(),
            "structure": StructureCritic()
        }
      
    def multidimensional_reflection(self, paper_draft):
        """多维度反思与改进"""
        # 并行收集各维度反馈
        all_feedback = {}
        for dimension, critic in self.critics.items():
            feedback = critic.analyze(paper_draft)
            all_feedback[dimension] = feedback
      
        # 优先级排序
        prioritized = self.prioritize_feedback(all_feedback)
      
        improvements = []
        for dimension, feedback in prioritized:
            # 生成具体修改建议
            suggestions = self.generate_suggestions(dimension, feedback)
          
            # 应用改进
            if self.should_apply_now(suggestions, dimension):
                improved_draft = self.apply_improvements(
                    paper_draft, suggestions
                )
                improvements.append((dimension, improved_draft))
      
        # 冲突解决
        if self.has_conflicts(improvements):
            final_draft = self.resolve_conflicts(improvements)
        else:
            final_draft = self.merge_improvements(improvements)
      
        return {
            "final_draft": final_draft,
            "feedback_by_dimension": all_feedback,
            "applied_improvements": improvements
        }
  
    def prioritize_feedback(self, feedback_dict):
        """基于严重性和影响排序"""
        priority_scores = {}
      
        for dimension, feedback in feedback_dict.items():
            score = 0
          
            # 严重性权重
            severity_weights = {
                "critical": 3.0,
                "major": 2.0,
                "minor": 1.0
            }
          
            for issue in feedback.get("issues", []):
                severity = issue.get("severity", "minor")
                score += severity_weights.get(severity, 1.0)
          
            # 维度重要性权重
            dimension_weights = {
                "logic": 1.5,      # 逻辑性最重要
                "citation": 1.2,   # 引用规范很关键
                "innovation": 1.0,
                "structure": 0.9,
                "language": 0.8
            }
          
            score *= dimension_weights.get(dimension, 1.0)
            priority_scores[dimension] = score
      
        # 按优先级排序
        return sorted(
            feedback_dict.items(), 
            key=lambda x: priority_scores.get(x[0], 0), 
            reverse=True
        )

class LogicCritic:
    """逻辑性评审专家"""
    def analyze(self, paper):
        issues = []
      
        # 检查论点一致性
        if not self.check_argument_consistency(paper):
            issues.append({
                "type": "argument_inconsistency",
                "severity": "critical",
                "description": "文中存在矛盾论点",
                "location": self.find_inconsistent_sections(paper)
            })
      
        # 检查推理链条
        if not self.check_reasoning_chain(paper):
            issues.append({
                "type": "broken_reasoning_chain",
                "severity": "major",
                "description": "推理步骤不连贯",
                "suggestion": "添加过渡句或明确逻辑连接"
            })
      
        return {"issues": issues, "score": self.calculate_logic_score(paper)}

class CitationCritic:
    """引用规范评审专家"""
    def analyze(self, paper):
        issues = []
      
        # 检查格式一致性
        formats = self.extract_citation_formats(paper)
        if len(set(formats)) > 1:
            issues.append({
                "type": "citation_format_inconsistency",
                "severity": "major",
                "description": f"发现{len(set(formats))}种引用格式",
                "suggestion": "统一为{recommended_format}格式"
            })
      
        # 检查是否引用关键文献
        missing_key = self.check_key_citations(paper)
        if missing_key:
            issues.append({
                "type": "missing_key_citations",
                "severity": "critical",
                "description": f"缺失{len(missing_key)}篇关键文献",
                "suggested_citations": missing_key
            })
      
        return {"issues": issues, "score": self.calculate_citation_score(paper)}
```

## 习题6：提示词工程分析

### 6.1 不同范式的提示词结构对比

```python
# ReAct提示词模板（强调循环）
react_prompt_template = """
你是一个ReAct智能体。请按照以下格式回应：

思考
```



